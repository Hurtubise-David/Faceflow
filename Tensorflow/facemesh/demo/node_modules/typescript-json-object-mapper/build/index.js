(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("tjom", [], factory);
	else if(typeof exports === 'object')
		exports["tjom"] = factory();
	else
		root["tjom"] = factory();
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class JsonView {
}
exports.JsonView = JsonView;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Serialization {
    constructor(serialized) {
        this.serialized = serialized;
    }
    toString(space = 4) {
        return JSON.stringify(this.serialized, null, space);
    }
    toJson() {
        return this.serialized;
    }
}
exports.Serialization = Serialization;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var JsonProperty_1 = __webpack_require__(3);
exports.JsonProperty = JsonProperty_1.JsonProperty;
var JsonIgnore_1 = __webpack_require__(5);
exports.JsonIgnore = JsonIgnore_1.JsonIgnore;
var JsonView_1 = __webpack_require__(0);
exports.JsonView = JsonView_1.JsonView;
var Serialization_1 = __webpack_require__(1);
exports.Serialization = Serialization_1.Serialization;
var JsonObjectMapper_1 = __webpack_require__(6);
exports.JsonObjectMapper = JsonObjectMapper_1.JsonObjectMapper;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(4);
function JsonProperty(...args) {
    const KEY = "JSON:PROPERTY";
    if (args.length > 2) {
        const designType = Reflect.getMetadata("design:type", args[0], args[1]);
        let pre = Reflect.getMetadata(KEY, args[0]) || {};
        pre[args[1]] = Object.assign({}, pre[args[1]], { name: args[1], type: designType.name.toLowerCase() });
        Reflect.defineMetadata(KEY, pre, args[0]);
        return void 0;
    }
    else {
        return (...params) => {
            const designType = Reflect.getMetadata("design:type", params[0], params[1]);
            let options = {};
            if (typeof args[0] === 'function')
                options.view = args[0];
            else
                options = args[0];
            let pre = Reflect.getMetadata(KEY, params[0]) || {};
            pre[params[1]] = Object.assign({}, pre[params[1]], { 
                // view: designType.name,
                type: designType.name, name: params[1] }, options);
            Reflect.defineMetadata(KEY, pre, params[0]);
        };
    }
}
exports.JsonProperty = JsonProperty;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("reflect-metadata");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function JsonIgnore(...args) {
    const KEY = "JSON:PROPERTY";
    if (args.length > 2) {
        let pre = Reflect.getMetadata(KEY, args[0]) || {};
        if (typeof pre[args[1]] === "object") {
            pre[args[1]].ignore = true;
        }
        else {
            pre[args[1]] = { ignore: true };
        }
        Reflect.defineMetadata(KEY, pre, args[0]);
        return void 0;
    }
    else {
        return (...params) => {
            let pre = Reflect.getMetadata(KEY, params[0]) || {};
            if (typeof pre[params[1]] === "object") {
                pre[params[1]].ignore = true;
            }
            else {
                pre[params[1]] = { ignore: true };
            }
            Reflect.defineMetadata(KEY, pre, params[0]);
        };
    }
}
exports.JsonIgnore = JsonIgnore;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const JsonView_1 = __webpack_require__(0);
const Serialization_1 = __webpack_require__(1);
class JsonObjectMapper {
    static serialize(...args) {
        let immutably;
        if (Array.isArray(args[0])) {
            immutably = args[0].slice();
        }
        else {
            immutably = Object.assign({}, args[0]);
        }
        const isObject = (inputObject) => typeof inputObject === "object";
        const isPlainObject = (inputObject) => Object.prototype.toString.call(inputObject) === '[object Object]';
        const isConstructor = (inputConstructor) => !!inputConstructor.prototype && !!inputConstructor.prototype.constructor.name;
        const filter = (target, input) => {
            const jsonProperties = Reflect.getMetadata("JSON:PROPERTY", target.prototype) || {};
            for (let prop in input) {
                if (typeof jsonProperties[prop] === 'undefined') {
                    if (typeof input === 'string') {
                        input = null;
                        break;
                    }
                    else {
                        delete input[prop];
                    }
                    continue;
                }
                // if is a object constructor or not a plain object
                else if (isObject(input[prop]) && !Array.isArray(input[prop])) {
                    // if is a constructor, class or function, I trying convert to string
                    if (!isPlainObject(input[prop]) || isConstructor(input[prop])) {
                        delete jsonProperties[prop].view;
                        jsonProperties[prop].type = 'string';
                        input[prop] = JSON.stringify(input[prop]);
                    }
                    else if (typeof input[prop].constructor === "function") {
                        let toString;
                        if (typeof input[prop].toString === "function") {
                            toString = input[prop].toString();
                        }
                        if (toString === '[object Object]') {
                            const properties = {};
                            for (const property of Object.keys(input[prop])) {
                                properties[property] = input[prop][property];
                            }
                            input[prop] = JSON.parse(JSON.stringify(properties));
                            jsonProperties[prop].type = 'object';
                        }
                        else {
                            delete jsonProperties[prop].view;
                            jsonProperties[prop].type = 'string';
                            input[prop] = toString;
                        }
                    }
                }
                // topic filter
                if (typeof args[2] === "string" || Array.isArray(args[2])) {
                    if (jsonProperties[prop].topic && jsonProperties[prop].topic.length > 0) {
                        // serialize topic is string, convert it to string-array
                        if (typeof args[2] === "string") {
                            args[2] = [args[2]];
                        }
                        // and now, if the current property not have som topic...
                        if (args[2].indexOf(jsonProperties[prop].topic) === -1) {
                            delete input[prop];
                            continue;
                        }
                    }
                }
                if (jsonProperties[prop].ignore === true) {
                    delete input[prop];
                    continue;
                }
                if (typeof jsonProperties[prop].type === "string") {
                    switch (jsonProperties[prop].type.toLowerCase()) {
                        case 'date':
                            if (typeof input[prop] === 'number') {
                                input[prop] = new Date(input[prop]);
                            }
                            else if (typeof input[prop] === 'string') {
                                input[prop] = new Date(Date.parse(input[prop]));
                            }
                            else if (input[prop] instanceof Date) {
                                continue;
                            }
                            else {
                                input[prop] = null;
                            }
                            break;
                        case 'number':
                            if (typeof input[prop] !== 'number') {
                                input[prop] = Number(input[prop]);
                            }
                            break;
                        case 'string':
                            if (typeof input[prop] !== 'string') {
                                input[prop] = String(input[prop]);
                            }
                            break;
                        case 'boolean':
                            input[prop] = input[prop] === true || input[prop] > 0 || input[prop] !== false || typeof input[prop] !== 'undefined' || input[prop] !== null;
                            break;
                    }
                }
                if (typeof jsonProperties[prop].view !== 'undefined' && jsonProperties[prop].view !== null) {
                    if (typeof input[prop] === "object") {
                        if (Array.isArray(jsonProperties[prop].view)) {
                            if (jsonProperties[prop].view.length !== 1) {
                                delete input[prop];
                                continue;
                            }
                            if (jsonProperties[prop].view[0].prototype instanceof JsonView_1.JsonView) {
                                for (let i = 0; i < input[prop].length; i++) {
                                    if (typeof input[prop][i] === 'object' && input[prop][i] !== null) {
                                        input[prop][i] = filter(jsonProperties[prop].view[0], input[prop][i]);
                                    }
                                    else {
                                        input[prop][i] = null;
                                    }
                                }
                            }
                            else {
                                delete input[prop];
                            }
                        }
                        else if (jsonProperties[prop].view.prototype instanceof JsonView_1.JsonView) {
                            input[prop] = filter(jsonProperties[prop].view, input[prop]);
                        }
                        else {
                            // input[prop] = null;
                        }
                    }
                }
            }
            for (let prop in input) {
                if (jsonProperties[prop].name !== prop) {
                    // change name of property
                    input[jsonProperties[prop].name] = input[prop];
                    if (Array.isArray(input) && typeof prop === 'number') {
                        input.splice(prop, 1);
                    }
                    else {
                        delete input[prop];
                    }
                }
            }
            return input;
        };
        let result;
        if (Array.isArray(immutably)) {
            result = immutably
                .map(data => JsonObjectMapper.serialize(data, args[1], args[2]).toJson());
        }
        else {
            result = filter(args[1], immutably);
        }
        return new Serialization_1.Serialization(result);
    }
}
exports.JsonObjectMapper = JsonObjectMapper;


/***/ })
/******/ ]);
});
//# sourceMappingURL=index.js.map