"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var result_1 = require("./result");
var JsonDecoder;
(function (JsonDecoder) {
    var Decoder = /** @class */ (function () {
        function Decoder(decodeFn) {
            this.decodeFn = decodeFn;
        }
        /**
         * Decodes a JSON object of type <a> and returns a Result<a>
         * @param json The JSON object
         */
        Decoder.prototype.decode = function (json) {
            return this.decodeFn(json);
        };
        /**
         * Decodes a JSON object of type <a> and calls onOk() on success or onErr() on failure, both return <b>
         * @param json The JSON object to decode
         * @param onOk function called when the decoder succeeds
         * @param onErr function called when the decoder fails
         */
        Decoder.prototype.onDecode = function (json, onOk, onErr) {
            var result = this.decode(json);
            if (result.isOk()) {
                return onOk(result.value);
            }
            else {
                return onErr(result.error);
            }
        };
        /**
         * Decodes a JSON object of type <a> and returns a Promise<a>
         * @param json The JSON object to decode
         */
        Decoder.prototype.decodePromise = function (json) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var result = _this.decode(json);
                if (result.isOk()) {
                    return resolve(result.value);
                }
                else {
                    return reject(result.error);
                }
            });
        };
        /**
         * Chains decoder result transformations
         * @param fn The transformation function
         */
        Decoder.prototype.map = function (fn) {
            var _this = this;
            return new Decoder(function (json) {
                var result = _this.decodeFn(json);
                if (result.isOk()) {
                    return result_1.ok(fn(result.value));
                }
                else {
                    return result_1.err(result.error);
                }
            });
        };
        /**
         * Chains decoders
         * @param fn Function that returns a new decoder
         */
        Decoder.prototype.then = function (fn) {
            var _this = this;
            return new Decoder(function (json) {
                var result = _this.decodeFn(json);
                if (result.isOk()) {
                    return fn(result.value).decode(json);
                }
                else {
                    return result_1.err(result.error);
                }
            });
        };
        return Decoder;
    }());
    JsonDecoder.Decoder = Decoder;
    /**
     * Decoder for recursive data structures.
     *
     * @param mkDecoder A function that returns a decoder
     */
    function lazy(mkDecoder) {
        return new Decoder(function (json) { return mkDecoder().decode(json); });
    }
    JsonDecoder.lazy = lazy;
    /**
     * Decoder for `string`.
     */
    JsonDecoder.string = new Decoder(function (json) {
        if (typeof json === 'string') {
            return result_1.ok(json);
        }
        else {
            return result_1.err($JsonDecoderErrors.primitiveError(json, 'string'));
        }
    });
    /**
     * Decoder for `number`.
     */
    JsonDecoder.number = new Decoder(function (json) {
        if (typeof json === 'number') {
            return result_1.ok(json);
        }
        else {
            return result_1.err($JsonDecoderErrors.primitiveError(json, 'number'));
        }
    });
    /**
     * Decoder for `boolean`.
     */
    JsonDecoder.boolean = new Decoder(function (json) {
        if (typeof json === 'boolean') {
            return result_1.ok(json);
        }
        else {
            return result_1.err($JsonDecoderErrors.primitiveError(json, 'boolean'));
        }
    });
    /**
     * Decoder for objects.
     *
     * @param decoders Key/value pairs of decoders for each object field.
     * @param decoderName How to display the name of the object being decoded in errors.
     * @param keyMap Optional map between json field names and user land field names.
     *               Useful when the client model does not match with what the server sends.
     */
    function object(decoders, decoderName, keyMap) {
        return new Decoder(function (json) {
            if (json !== null && typeof json === 'object') {
                var result = {};
                for (var key in decoders) {
                    if (decoders.hasOwnProperty(key)) {
                        if (keyMap && key in keyMap) {
                            var jsonKey = keyMap[key];
                            var r = decoders[key].decode(json[jsonKey]);
                            if (r.isOk()) {
                                result[key] = r.value;
                            }
                            else {
                                return result_1.err($JsonDecoderErrors.objectJsonKeyError(decoderName, key, jsonKey, r.error));
                            }
                        }
                        else {
                            var r = decoders[key].decode(json[key]);
                            if (r.isOk()) {
                                result[key] = r.value;
                            }
                            else {
                                return result_1.err($JsonDecoderErrors.objectError(decoderName, key, r.error));
                            }
                        }
                    }
                }
                return result_1.ok(result);
            }
            else {
                return result_1.err($JsonDecoderErrors.primitiveError(json, decoderName));
            }
        });
    }
    JsonDecoder.object = object;
    /**
     * Decoder for objects that performs strict key checks.
     * The decoder will fail if there are any extra keys in the provided object.
     *
     * @param decoders Key/value pairs of decoders for each object field.
     * @param decoderName How to display the name of the object being decoded in errors.
     */
    function objectStrict(decoders, decoderName) {
        return new Decoder(function (json) {
            if (json !== null && typeof json === 'object') {
                for (var key in json) {
                    if (!decoders.hasOwnProperty(key)) {
                        return result_1.err($JsonDecoderErrors.objectStrictUnknownKeyError(decoderName, key));
                    }
                }
                var result = {};
                for (var key in decoders) {
                    if (decoders.hasOwnProperty(key)) {
                        var r = decoders[key].decode(json[key]);
                        if (r.isOk()) {
                            result[key] = r.value;
                        }
                        else {
                            return result_1.err($JsonDecoderErrors.objectError(decoderName, key, r.error));
                        }
                    }
                }
                return result_1.ok(result);
            }
            else {
                return result_1.err($JsonDecoderErrors.primitiveError(json, decoderName));
            }
        });
    }
    JsonDecoder.objectStrict = objectStrict;
    /**
     * Always succeeding decoder
     */
    JsonDecoder.succeed = new Decoder(function (json) {
        return result_1.ok(json);
    });
    /**
     * Always failing decoder
     */
    function fail(error) {
        return new Decoder(function (json) {
            return result_1.err(error);
        });
    }
    JsonDecoder.fail = fail;
    /**
     * Tries to decode with `decoder` and returns `defaultValue` on failure.
     * (It was called maybe() before)
     *
     * @param defaultValue The default value returned in case of decoding failure.
     * @param decoder The actual decoder to use.
     */
    function failover(defaultValue, decoder) {
        return new Decoder(function (json) {
            var result = decoder.decode(json);
            if (result.isOk()) {
                return result;
            }
            else {
                return result_1.ok(defaultValue);
            }
        });
    }
    JsonDecoder.failover = failover;
    /**
     * Tries to decode with `decoder` and returns `error` on failure, but allows
     * for `undefined` or `null` values to be present at the top level and returns
     * an `undefined` if the value was `undefined` or `null`.
     *
     * @param decoder The actual decoder to use.
     */
    function optional(decoder) {
        return new Decoder(function (json) {
            if (json === undefined) {
                return result_1.ok(undefined);
            }
            else if (json === null) {
                return result_1.ok(undefined);
            }
            else {
                return decoder.decode(json);
            }
        });
    }
    JsonDecoder.optional = optional;
    /**
     * Tries to decode with `decoder` and returns `error` on failure, but allows for `null` value.
     *
     * @param decoder The actual decoder to use
     */
    function nullable(decoder) {
        return new Decoder(function (json) {
            if (json === null) {
                return result_1.ok(null);
            }
            return decoder.decode(json);
        });
    }
    JsonDecoder.nullable = nullable;
    /**
     * Tries to decode the provided json value with any of the provided `decoders`.
     * If all provided `decoders` fail, this decoder fails.
     * Otherwise, it returns the first successful decoder.
     *
     * @param decoders An array of decoders to try.
     */
    function oneOf(decoders, decoderName) {
        return new Decoder(function (json) {
            for (var i = 0; i < decoders.length; i++) {
                var result = decoders[i].decode(json);
                if (result.isOk()) {
                    return result;
                }
            }
            return result_1.err($JsonDecoderErrors.oneOfError(decoderName, json));
        });
    }
    JsonDecoder.oneOf = oneOf;
    /**
     * Tries to decode the provided json value with all of the provided `decoders`.
     * The order of the provided decoders matters: the output of one decoder is passed
     * as input to the next decoder. If any of the provided `decoders` fail, this
     * decoder fails. Otherwise, it returns the output of the last decoder.
     *
     * @param decoders a spread of decoders to use.
     */
    function allOf() {
        var decoders = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            decoders[_i] = arguments[_i];
        }
        return new Decoder(function (json) {
            return decoders.reduce(function (prev, curr) {
                return (prev.isOk() ? curr.decode(prev.value) : prev);
            }, result_1.ok(json));
        });
    }
    JsonDecoder.allOf = allOf;
    /**
     * Decoder for key/value pairs.
     *
     * @param decoder An object decoder for the values. All values must have the same shape or use oneOf otherwise.
     */
    JsonDecoder.dictionary = function (decoder, decoderName) {
        return new Decoder(function (json) {
            if (json !== null && typeof json === 'object') {
                var obj = {};
                for (var key in json) {
                    if (json.hasOwnProperty(key)) {
                        var result = decoder.decode(json[key]);
                        if (result.isOk()) {
                            obj[key] = result.value;
                        }
                        else {
                            return result_1.err($JsonDecoderErrors.dictionaryError(decoderName, key, result.error));
                        }
                    }
                }
                return result_1.ok(obj);
            }
            else {
                return result_1.err($JsonDecoderErrors.primitiveError(json, 'dictionary'));
            }
        });
    };
    /**
     * Decoder for Array<T>.
     *
     * @param decoder The decoder for the array element.
     */
    JsonDecoder.array = function (decoder, decoderName) {
        return new Decoder(function (json) {
            if (json instanceof Array) {
                var arr = [];
                for (var i = 0; i < json.length; i++) {
                    var result = decoder.decode(json[i]);
                    if (result.isOk()) {
                        arr.push(result.value);
                    }
                    else {
                        return result_1.err($JsonDecoderErrors.arrayError(decoderName, i, result.error));
                    }
                }
                return result_1.ok(arr);
            }
            else {
                return result_1.err($JsonDecoderErrors.primitiveError(json, 'array'));
            }
        });
    };
    /**
     * Decoder that only succeeds when json is strictly (===) `null`.
     * When succeeds it returns `defaultValue`.
     *
     * @param defaultValue The value returned when json is `null`.
     */
    function isNull(defaultValue) {
        return new Decoder(function (json) {
            if (json === null) {
                return result_1.ok(defaultValue);
            }
            else {
                return result_1.err($JsonDecoderErrors.nullError(json));
            }
        });
    }
    JsonDecoder.isNull = isNull;
    /**
     * Decoder that only succeeds when json is strictly (===) `undefined`.
     * When succeeds it returns `defaultValue`.
     *
     * @param defaultValue The value returned when json is `undefined`.
     */
    function isUndefined(defaultValue) {
        return new Decoder(function (json) {
            if (json === undefined) {
                return result_1.ok(defaultValue);
            }
            else {
                return result_1.err($JsonDecoderErrors.undefinedError(json));
            }
        });
    }
    JsonDecoder.isUndefined = isUndefined;
    /**
     * Decoder that always succeeds returning `value`.
     *
     * @param value The value returned.
     */
    JsonDecoder.constant = function (value) {
        return new Decoder(function (json) { return result_1.ok(value); });
    };
    /**
     * Decoder that only succeeds when json is strictly (===) `value`.
     * When succeeds it returns `value`.
     *
     * @param value The value returned on success.
     */
    function isExactly(value) {
        return new Decoder(function (json) {
            if (json === value) {
                return result_1.ok(value);
            }
            else {
                return result_1.err($JsonDecoderErrors.exactlyError(json, value));
            }
        });
    }
    JsonDecoder.isExactly = isExactly;
    /**
     * Combines a list of decoders into a single decoder
     * which result is an intersection type of input decoders.
     *
     * Example:
     *
     *    > JsonDecoder.combine(Decoder<User>, Decoder<Metadata>)
     *    // => Decoder<User & Metadata>
     *
     * @param decoders Variable arguments list of decoders
     */
    function combine() {
        var decoders = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            decoders[_i] = arguments[_i];
        }
        return new Decoder(function (json) {
            try {
                var finalResult = decoders.reduce(function (acc, decoder) {
                    var result = decoder.decode(json);
                    if (result.isOk()) {
                        return __assign(__assign({}, acc), result.value);
                    }
                    throw result.error;
                }, {});
                return result_1.ok(finalResult);
            }
            catch (error) {
                return result_1.err(error);
            }
        });
    }
    JsonDecoder.combine = combine;
})(JsonDecoder = exports.JsonDecoder || (exports.JsonDecoder = {}));
var $JsonDecoderErrors;
(function ($JsonDecoderErrors) {
    $JsonDecoderErrors.primitiveError = function (value, tag) {
        return JSON.stringify(value) + " is not a valid " + tag;
    };
    $JsonDecoderErrors.exactlyError = function (json, value) {
        return JSON.stringify(json) + " is not exactly " + JSON.stringify(value);
    };
    $JsonDecoderErrors.undefinedError = function (json) {
        return JSON.stringify(json) + " is not undefined";
    };
    $JsonDecoderErrors.nullError = function (json) {
        return JSON.stringify(json) + " is not null";
    };
    $JsonDecoderErrors.dictionaryError = function (decoderName, key, error) {
        return "<" + decoderName + "> dictionary decoder failed at key \"" + key + "\" with error: " + error;
    };
    $JsonDecoderErrors.oneOfError = function (decoderName, json) {
        return "<" + decoderName + "> decoder failed because " + JSON.stringify(json) + " can't be decoded with any of the provided oneOf decoders";
    };
    $JsonDecoderErrors.objectError = function (decoderName, key, error) {
        return "<" + decoderName + "> decoder failed at key \"" + key + "\" with error: " + error;
    };
    $JsonDecoderErrors.arrayError = function (decoderName, index, error) {
        return "<" + decoderName + "> decoder failed at index \"" + index + "\" with error: " + error;
    };
    $JsonDecoderErrors.objectJsonKeyError = function (decoderName, key, jsonKey, error) {
        return "<" + decoderName + "> decoder failed at key \"" + key + "\" (mapped from the JSON key \"" + jsonKey + "\") with error: " + error;
    };
    $JsonDecoderErrors.objectStrictUnknownKeyError = function (decoderName, key) {
        return "Unknown key \"" + key + "\" found while processing strict <" + decoderName + "> decoder";
    };
})($JsonDecoderErrors = exports.$JsonDecoderErrors || (exports.$JsonDecoderErrors = {}));
